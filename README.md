# Лабораторная работа
# Тема: "Оптимизация алгоритма расчета множества Мандельброта с помощью SIMD" 
<br>

### Александров Олег
### Б05-331 
### 29.03.2024 

<br>

# Цель работы 
Исследовать влияние оптимизаций компилятора и SIMD инструкций на время работы программы.

# Содержание
1. [Титульный лист](#лабораторная-работа)
2. [Реализация](#реализация)
    1. [Теоретическая справка](#теоретическая-справка)
    2. [Запуск программы](#запуск-программы)
        1. [Зависимости](#зависимости)
    3. [Реализованные режимы](#реализованные-режимы)
        1. [Тестовой режим](#тестовой-режим)
        2. [Графический режим](#графический-режим)
    4. [Реализованные алгоритмы](#реализованные-алгоритмы)
        1. [Простая реализация](#простая-реализация)
        2. [Векторная реализация](#векторная-реализация)
        3. [AVX реализация](#AVX-реализация)
3. [Измерение времени](#измерение-врмени)
    1. [Методика измерений](#методика-измерений)
    2. [Оборудование](#оборудование)
    3. [Результаты](#результаты)
    4. [Анализ результатов](#анализ-результатов)
4. [Вывод](#вывод)
5. [Благодарности](#благодарности)
6. [Библиографический список](#библиографический-список)
7. [Приложение](#приложение)

# Реализация

## Теоретическая справка

![Множество Мандельброта](/images/mandelbrot_set.png)

Рассмотрим действительную плоскость и точку из области построения на ней. Координаты точки будем обозначать как $x_0$ и $y_0$. Для каждой точки рассмотрим последовательность, каждый следующий элемент которой будет вычисляться по формуле:

$$y_{n+1} = 2 x_n y_n + x_0$$

$$x_{n+1} = x_n^2 - y_n^2 + y_0$$

Вычисления будут проводиться, пока $n < 256$ и $x_n^2 + y_n^2 \leq 100$. 

Цвет пикселя изображения зависит от $n$. Библиотека [SFML](https://www.sfml-dev.org/) задаёт цвет пикселя в формате `rgba`. Далее цвет рассчитывается по формуле: Если $n = 256$, то цвет - черный, иначе : 

|        R        |        G       |         B        |   A   |
|:---------------:|:--------------:|:----------------:|:-----:|
| $255 * sin(n)$  | $255 * cos(n)$ | $255 * sin(2 n)$ | $255$ |

## Запуск программы

Запуск быстрой реализации подсчета [множества Мандельброта](https://mathworld.wolfram.com/MandelbrotSet.html):

```
git clone git@github.com:Ch1n-ch1nless/MandelbrotSet.git
cd MandelbrotSet
make OPT_LEVEL=-O3
./mandelbrot_set -g -i avx
```

Данный код запускает программу в графическом режиме и с реализацией алгоритма, использующий [SIMD]() инструкции. \
Про другие режимы и инструкции в разделах:
[Реализованные режимы](#реализованные-режимы) и [Реализованные алгоритмы](#реализованные-алгоритмы)

Теперь подробнее про команды:
В makefile надо указать значение переменной OPT_LEVEL, в которой хранится уровень оптимизации программы(-O0, -O3, ...)

```
make OPT_LEVEL=<уровень оптимизации>
```

Гайд по запуску программы:
Флаги:
```
-h  -- показать гайд, как правильно запустить программу.
-t  -- запустить программу в тестовом режиме.
-g  -- запустить программу в графическом режиме.
```
Так же необходимо указать реализацию функции подсчета множества Мандельброта.
```
-i simple   -- алгоритм будет считать, каждый пиксель на экране отдельно
-i vector   -- алгоритм считает по 8 пикселей за раз без использования SIMD инструкций
-i avx      -- алгоритм считает по 8 пикселей за заз с использованием SIMD инструкций
```

Примеры запуска:
```
./mandelbrot_set -g -i vector   # запустить программу в графическом режиме и векторной реализации
./mandelbrot_set -i simple -t   # запустить программу в тестовом режиме и попиксельной реализации
```

### Зависимости

Для графики была использована библиотека: [SFML](https://www.sfml-dev.org/) <br>
Так же использовались x86-64 и [AVX](https://www.laruence.com/sse/#techs=AVX)/[AVX2](https://www.laruence.com/sse/#techs=AVX2) инструкции.

## Реализованные режимы

Всего было написано 2 режима: тестовый(`-t`) и графический(`-g`).

### Тестовой режим

Программа 100 раз прогоняет алгоритм расчета множества Мандельброта. Во время каждого прогона выводит количество тактов, затраченных на исполнение данного алгоритма.

Пример кода на Си:

``` C
void TestFunction(void (*CalculateMandelbrotSet)(unsigned int* pixel_array, Coords* coords_begin))
{
    assert((CalculateMandelbrotSet != nullptr) && "Pointer on function is NULL!!!\n");

    //Create array, which contains colors of pixels
    unsigned int* pixel_array = (unsigned int*) calloc(SCREEN_HEIGHT * SCREEN_WIDTH, sizeof(unsigned int));
    assert((pixel_array != nullptr) && "Program can not allocate memory!\n");

    Coords coords_begin = {};   //< Structure, which contains camera position coordinates

    for (int i = 0; i < 100; i++)
    {
        unsigned long long time_begin   = __rdtsc();        //< Detect the number of clock cycles before the algorithm is executed
        CalculateMandelbrotSet(pixel_array, &coords_begin); //< Algorithm
        unsigned long long time_end     = __rdtsc();        //< Detect the number of clock cycles after the algorithm is executed
        printf("%lld\n", time_end - time_begin);            //< Print on the screen number of clock cycles.
    }

    free(pixel_array);
}
```

### Графический режим

Программа запускает окно $800 \times 600$, где рисуется множество Мандельброта. В левом верхнем углу показывается FPS.

![Управление множеством Мандельброта](/images/mandelbrot_set.gif)

<kbd>←</kbd> -- Переместить камеру влево    \
<kbd>↑</kbd> -- Переместить камеру вверх    \
<kbd>→</kbd> -- Переместить камеру вправо   \
<kbd>↓</kbd> -- Переместить камеру вниз     \
\
<kbd>+</kbd> -- Приблизить камеру   \
<kbd>-</kbd> -- Отдалить камеру     \
\
<kbd>Esc</kbd> -- Выйти из программы 

## Реализованные режимы

### Простая реализация

В дальнейшем данная реализация в таблицах расчетов будет помечаться, как `SIMPLE`. \
Простая реализация заключается в переводе на язык Си всего, что было написано в [теоретической справке](#теоретическая-справка).
Сам алгоритм в теле цикла пересчета элементов последовательности обрабатывает 1 пиксель. 

Примера кода на `C` можно увидеть по [ссылке](https://github.com/Ch1n-ch1nless/MandelbrotSet/blob/4e1cae34593f027b608469ad3a83d6037623ba7e/source/mandelbrot_calc.cpp#L3).  

### Векторная реализация

В дальнейшем данная реализация в таблицах расчетов будет помечаться, как `VECTOR`. \
Данная реализация отличается от простой реализации тем, что алгоритм в теле цикла одновременно обрабатывает 8 пикселей. 
Тем самым пытаемся показать компилятору возможность к ускорения за счет параллельного вычисления. 

Примера кода на `C` можно увидеть по [ссылке](https://github.com/Ch1n-ch1nless/MandelbrotSet/blob/4e1cae34593f027b608469ad3a83d6037623ba7e/source/mandelbrot_calc.cpp#L38). 

### Avx реализация

В дальнейшем данная реализация в таблицах расчетов будет помечаться, как `AVX`. \
В данной реализации используются машинно зависимых векторных инструкций процессора. \
В моей реализации были использованы команды с [зеркала intel intrinsic guide](https://www.laruence.com/sse/#techs=AVX,AVX2). 

Примера кода на `C` можно увидеть по [ссылке](https://github.com/Ch1n-ch1nless/MandelbrotSet/blob/4e1cae34593f027b608469ad3a83d6037623ba7e/source/mandelbrot_calc.cpp#L91).  

# Измерение времени

## Методика измерений

Измерение времени производилось с помощью функции [__rdtsc()](https://learn.microsoft.com/ru-ru/cpp/intrinsics/rdtsc?view=msvc-170). Эта функция возвращает количество тактов с момента последнего сброса процессора(CPU reset). \
Само  измерение времени для каждой реализации алгоритма происходило в [тестовом режиме](#тестовой-режим). Каждый тест запускался по `5` раз.

## Оборудование

**Компилятор**: `g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0` \
**Уровни оптимизаций**: `-O0, -O1, -O2, -O3` \
[Список всех флагов](#полный-список-всех-флагов) \
**Процессор** : \
![характеристики процессора](/images/proc.png) \
**ОС** : `Linux Ubuntu 22.04.4 LTS (64-bit)`. Все тесты были проведены в режиме "Performance"

## Результаты

Все таблицы с результатами можно увидеть по [ссылке](#таблица-1). 
Тут будет показана диаграмма по результатам [финальной таблицы](#финальная-таблица) и относительный прирост в скорости работы алгоритма.

![Диаграмма ](/images/diagram.png)

Таблица прироста в процентах производительности относительно простой реализации с уровнем оптимизации = -O0.

|       |   -O0 |   -O1 |   -O2 |   -O3 |
|:-----:|:-----:|:-----:|:-----:|:-----:|
| SIMPLE|  100% |  277% |  303% |  302% |
| VECTOR|   39% |  187% |  198% |  590% |
| AVX   |  277% | 1956% | 1956% | 2020% | 

## Анализ результатов

После данных измерений меня больше всего удивило, что в векторной реализации при флаге -O3 производительность в 3 раза больше, чем при -O2. произведя анализ их ассемблерного кода с помощью сайта [godbolt.org](https://godbolt.org/). Я получил следующие ассемблерные коды: \
[VECTOR -O2](https://godbolt.org/z/s4Gxv4Krc) и [VECTOR -O3](https://godbolt.org/z/PrqTYcn8K). \
Во многом, они похожи, но при -O3 работает быстрее в связи с большим количеством работы с XMM регистрами, чем при -O2. \
А реализация с AVX инструкции работает в ~10 раз, так как она использует YMM регистры, что ускоряет работу программы, в то время, как остальные нет. 
[Ссылка на godbolt.org](https://godbolt.org/z/jzbPqaYM7).

# Вывод

Из таблиц и графиков видно, что без попытки в параллелизм флаг оптимизации `-O3` ускоряет работу программы в 3 раза! \
При флаге `-O3` алгоритм, который не использует SIMD инструкции, но векторизует вычисления, ускоряет работу программы в ~6 раз! \
Использование SIMD инструкций ускоряет программу в ~20 раз!!! \
В данной лабораторной работе я научился пользоваться SIMD-инструкциями и убедился, что они сильно ускоряют в=работу программы. В дальнейшем, я буду использовать SIMD-инструкции чаще.

# Благодарности

[Дединский Илья Рудольфович](https://github.com/ded32) -- преподаватель курса \
[Мухорин Матвей](https://github.com/matmuher)          -- мой ментор

# Библиографический список

1. **Computer Systems: A Programmer's Perspective** 3rd Edition by **Randal Bryant**, **David O'Hallaron**
2. **Compiler explorer** - [godbolt.com](https://godbolt.com)
3. **Mirror of Intel Intrinsics Guide** - [laurence.com/sse](https://www.laruence.com/sse/)
4. **Лекции Северова Д.С.**  - [ссылка](https://www.youtube.com/watch?v=BjcJ1fK139s&list=PLthfp5exSWEoOGJTuRZAPrZNUmTrTaUZ4)
5. **Гайд по работе с SFML** - [ссылка](https://www.sfml-dev.org/tutorials/2.6/)

# Приложение

#### Полный список всех флагов

``` 
-Wshadow -Winit-self -Wredundant-decls -Wcast-align -Wundef -Wfloat-equal\
-Winline -Wunreachable-code -Wmissing-declarations -Wmissing-include-dirs \
-Wswitch-enum -Wswitch-default -Weffc++ -Wmain -Wextra -Wall -g -pipe -fexceptions\
-Wcast-qual -Wconversion -Wctor-dtor-privacy -Wempty-body -Wformat-security\
-Wformat=2 -Wignored-qualifiers -Wlogical-op -Wno-missing-field-initializers -Wnon-virtual-dtor\
-Woverloaded-virtual -Wpointer-arith -Wsign-promo -Wstack-usage=8192 -Wstrict-aliasing\
-Wstrict-null-sentinel -Wtype-limits -Wwrite-strings -Werror=vla\
-D_DEBUG -mavx2 -mfma -mavx -msse4.2
```

#### Таблица 1

Первый запуск тестов. В таблице указано среднее количество тактов.

|    1   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1283439571.84 |  448444564.8  |  410016640.32 |  422716402.56 |
| VECTOR | 3072940250.24 |  639090985.6  |  588554806.4  |  211630263.68 |
| AVX    |  434582454.4  |   60887493.12 |   60983936.32 |   60072843.84 |

#### Таблица 2

Второй запуск тестов. В таблице указано среднее количество тактов.

|    2   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1257265602.56 |  444082539.2  |  408647919.04 |  411939588.8  |
| VECTOR | 3266982525.76 |  669882133.12 |  655140738.88 |  228828652.8  |
| AVX    |  460258106.88 |   62694989.76 |   62216597.76 |   62121263.04 |

<h4>Таблица 3

Третий запуск. В таблице указано среднее количество тактов.

|    3   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1206867259.2  |  443740706.88 |  407006695.68 |  407068553.6  |
| VECTOR | 3158986114.24 |  647464094.4  |  635349811.84 |  222189628.16 |
| AVX    |  449727304.0  |   63756742.4  |   64575378.56 |   61044048.64 |

#### Таблица 4

4-ый запуск. В таблице указано среднее количество тактов.

|    4   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1206456320.96 |  443143494.08 |  407327719.04 |  407013029.44 |
| VECTOR | 3161458192.96 |  653433014.08 |  618613750.72 |  217610872.64 |
| AVX    |  438641075.52 |   63356642.56 |   63660352.32 |   60953052.16 |

#### Таблица 5

5-ый запуск. В таблице указано среднее количество тактов.

|    5   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1206640666.56 |  442867832.96 |  406931645.76 |  407244093.44 |
| VECTOR | 3103675312.96 |  654002534.08 |  614539704.64 |  219158337.92 |
| AVX    |  440524551.36 |   63067849.6  |   62766071.68 |   62159874.24 |

#### Финальная таблица

Данные в таблице имеют размерность такт * $10^6$. В каждой ячейке находится среднее значение количества тактов и погрешность.

| FINAL  |        -O0        |         -O1       |         -O2       |         -O3       |
|:------:|:-----------------:|:-----------------:|:-----------------:|:-----------------:|
| SIMPLE |$1232.13 \pm 32.28$| $444.46 \pm 2.04$ | $407.99 \pm 1.19$ | $411.20 \pm 6.06$ |
| VECTOR |$3152.78 \pm 66.24$| $652.77 \pm 10.10$| $622.43 \pm 22.19$| $219.88 \pm 5.64$ |
| AVX    | $444.74 \pm 9.20$ | $ 62.75 \pm 1$    | $ 62.84 \pm 1.23$ | $61.27  \pm 0.79$ |

#### Таблица относительной производительности:

SIMPLE = S, VECTOR = V и AVX = A. 

| col / row | S-O0  | S-O1  | S-O2  | S-O3  | V-O0  | V-O1  | V-O2  | V-O3  | A-O0  | A-O1  | A-O2  | A-O3  |
|:---------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|   S-O0    | 1.00  | 0.36  | 0.33  | 0.33  | 2.56  | 0.53  | 0.50  | 0.18  | 0.36  | 0.05  | 0.05  | 0.05  |
|   S-O1    | 2.79  | 1.00  | 0.92  | 0.92  | 7.10  | 0.68  | 0.71  | 0.49  | 1.00  | 0.14  | 0.14  | 0.14  |
|   S-O2    | 3.03  | 1.09  | 1.00  | 1.00  | 7.74  | 0.62  | 0.65  | 0.55  | 1.09  | 0.15  | 0.15  | 0.14  |
|   S-O3    | 3.00  | 1.09  | 1.00  | 1.00  | 7.67  | 0.63  | 0.64  | 0.53  | 1.08  | 0.15  | 0.15  | 0.15  |
|   V-O0    | 0.39  | 0.14  | 0.12  | 0.13  | 1.00  | 0.21  | 0.20  | 0.07  | 0.14  | 0.02  | 0.02  | 0.02  |
|   V-O1    | 1.98  | 1.47  | 1.60  | 1.59  | 4.83  | 1.00  | 0.95  | 0.34  | 0.68  | 0.10  | 0.10  | 0.09  |
|   V-O2    | 1.98  | 1.41  | 1.54  | 1.56  | 5.07  | 1.05  | 1.00  | 0.35  | 0.72  | 0.10  | 0.10  | 0.10  |
|   V-O3    | 5.60  | 2.02  | 1.85  | 1.87  | 14.07 | 2.96  | 2.83  | 1.00  | 2.02  | 0.29  | 0.29  | 0.28  | 
|   A-O0    | 2.77  | 0.99  | 0.91  | 0.92  | 7.08  | 1.46  | 1.40  | 0.49  | 1.00  | 0.14  | 0.14  | 0.14  |
|   A-O1    | 19.56 | 7.05  | 6.46  | 6.52  | 50.03 | 10.35 | 9.87  | 3.49  | 7.05  | 1.00  | 1.00  | 0.97  |
|   A-O2    | 19.56 | 7.05  | 6.46  | 6.52  | 50.03 | 10.35 | 9.87  | 3.49  | 7.05  | 1.00  | 1.00  | 0.97  |
|   A-O3    | 20.11 | 7.24  | 6.64  | 6.71  | 51.44 | 10.64 | 10.15 | 3.59  | 7.25  | 1.03  | 1.03  | 1.00  |
