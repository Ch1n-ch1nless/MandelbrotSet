# Лабораторная работа
# Тема: "Оптимизация алгоритма расчета множества Мандельброта с помощью [SIMD]()" 
<br>

### Александров Олег
### Б05-331 
### 29.03.2024 

<br>

# Цель работы 
1) Оптимизировать алгоритм расчета множества Мандельброта с помощью SIMD инструкций. \
2) Исследовать зависимость времени работы алгоритма от оптимизаций компилятора и SIMD инструкций 
# Оборудование 
<b>Компилятор</b>: g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0 \
<b>Уровни оптимизаций</b>: O0, O3 \
[Список всех флагов](#полный-список-всех-флагов) \
<b>Процессор</b> : AMD Ryzen 7 5800H, поддерживающий инструкции: AVX(1, 2) \
<b>ОС</b> : Linux Ubuntu 22.04.4 LTS (64-bit). Все тесты были проведены в режиме "Perfomance".\

# Ход работы 

## Зависимости

Для графики была использована библиотека: [SFML](https://www.sfml-dev.org/) <br>
Для машинно зависимых инструкций была использована библиотека: immintrin.h <br>
Другие стандартные библиотеки <br>

## Расчет множества Мандельброта
Математическая формула расчета Мандельброта: $z_{n+1} = z_{n}^2 + C_0$, где $z_0 = 0 + 0 * i$.
В моей реализации переменная $x = Re(z)$ и $y = Im(z)$. Считаем точки $(x_n, y_n)$ так:
    $$x_{n+1} = x_{n}^2 - y_{n}^2 + x_0$$
    $$y_{n+1} = 2 * x_{n} * y_{n} + y_0$$
Вычисления будут производится, пока $x_n^2 + y_n^2 < 100$ и $n \leq 256$. Исходя из n (n - номер итерации на которой закончились вычисления) выбирается цвет для точки $(x_0, y_0)$. Так же стоит заметить, что выбор цвета для 1 точки НЕ ЗАВИСИТ от других точек. Этот факт будет использован в 2 и 3 версии программы.

## Измерение времени 

### 1 версия

Алгоритм для каждого пикселя рассчитывает его координаты в системе координат, которую указал пользователь. Затем производятся вычисления, указанные в расчете. И красится пиксель.

Код расчета алгоритма:
``` C
//Сделать на псевдокоде!!!
void PerPixelCalculateMandelbrotSet(unsigned int* pixel_array, int x_shift, int y_shift, int zoom)
{
    for (int iy = 0; iy < SCREEN_HEIGHT; iy++)
    {
        for (int ix = 0; ix < SCREEN_WIDTH; ix++)
        {
            float x0 = x_shift + (((float)ix - SCREEN_WIDTH  / 2) * dX) * zoom;
            float y0 = y_shift + (((float)iy - SCREEN_HEIGHT / 2) * dY) * zoom * HEIGHT_WIDTH_RELATION;

            float x = x0;
            float y = y0;

            int number_of_iterations = 0;

            for ( ; number_of_iterations < MAX_NUMBER_OF_ITERATIONS; number_of_iterations++)
            {
                float x2 = x * x;
                float y2 = y * y;
                float xy = x * y;

                float r2 = x2 + y2;
                if (r2 > MAX_SQUARE_RADIUS) break;

                x = x2 - y2 + x0;
                y = xy + xy + y0;
            }

            pixel_array[iy * SCREEN_WIDTH + ix] = number_of_iterations; 
        }
    }
}
```

| Флаг компиляции |  FPS |   Такты    | 
|:---------------:|:----:|:----------:|
|       -O0       | 3.24 | 1180109382 |
|       -O3       | 9.86 |  366472583 |

### 2 версия 
Файл: "vector_realization.cpp". <br>
Алгоритм так же вычисляет точки множества Мандельброта по формуле: 
    $$z_{n+1} = z_{n}^2 + C_0$$
Однако, теперь алгоритм считает не 1 точку, а массив из 8 точек.
Результаты работы:

| Флаг компиляции |  FPS  |   Такты    |
|:---------------:|:-----:|:----------:|
|       -O0       |  1.27 | 2634282477 |
|       -O3       | 16.86 |  195826479 |

Можно заметить, что при O0 алгоритм версии 2 работает плохо. Это происходит из-за того, что компилятор не видит возможности замены команды на SIMD. В то время. как с флагом -O3, она обгоняет её! Так как компилятор видит возможность оптимизации кода и частичной замены на SIMD.

### 3 версия
Файл: "intrinsic_realization.cpp". <br>
В данной реализации для вычисления точек в множестве Мандельброта использовались SIMD-инструкции. Так как мой процессор поддерживает AVX2, то я использовал инструкции:
```
_mm256_add_ps();
_mm256_sub_ps();
_mm256_mul_ps();
_mm256_cmp_ps();
 и т.д. ...
```

В таблице ниже видно, что благодаря SIMD-инструкциям программа стала работать гораздо быстрее:

| Флаг компиляции |  FPS  |   Такты   |
|:---------------:|:-----:|:---------:|
|       -O0       |  8.78 | 377003918 |
|       -O3       | 55.23 |  55183899 |

## Финальная табличка

# Вывод 

Используя данные из финальной таблички, можно сделать выводы, что 
при компилировании с флагом -O3 время работы программы уменьшается в ~3 раза. <br>
При внедрении "векторизации" с флагом -O3 время работы программы уменьшается в ~6 раз. <br>
При использовании intrinsic функций с флагом O3 время работы уменьшается в ~21 раз <br>

# Приложение

#### Полный список всех флагов

``` 
-Wshadow -Winit-self -Wredundant-decls -Wcast-align -Wundef -Wfloat-equal\
-Winline -Wunreachable-code -Wmissing-declarations -Wmissing-include-dirs \
-Wswitch-enum -Wswitch-default -Weffc++ -Wmain -Wextra -Wall -g -pipe -fexceptions\
-Wcast-qual -Wconversion -Wctor-dtor-privacy -Wempty-body -Wformat-security\
-Wformat=2 -Wignored-qualifiers -Wlogical-op -Wno-missing-field-initializers -Wnon-virtual-dtor\
-Woverloaded-virtual -Wpointer-arith -Wsign-promo -Wstack-usage=8192 -Wstrict-aliasing\
-Wstrict-null-sentinel -Wtype-limits -Wwrite-strings -Werror=vla\
-D_DEBUG -mavx2 -mfma -mavx -msse4.2
```

<h4>Таблица #1</h4>

|    1   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1283439571.84 |  448444564.8  |  410016640.32 |  422716402.56 |
| VECTOR | 3072940250.24 |  639090985.6  |  588554806.4  |  211630263.68 |
| AVX    |  434582454.4  |   60887493.12 |   60983936.32 |   60072843.84 |

<h4>Таблица #2</h4>

|    2   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1257265602.56 |  444082539.2  |  408647919.04 |  411939588.8  |
| VECTOR | 3266982525.76 |  669882133.12 |  655140738.88 |  228828652.8  |
| AVX    |  460258106.88 |   62694989.76 |   62216597.76 |   62121263.04 |

<h4>Таблица #3</h4>

|    3   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1206867259.2  |  443740706.88 |  407006695.68 |  407068553.6  |
| VECTOR | 3158986114.24 |  647464094.4  |  635349811.84 |  222189628.16 |
| AVX    |  449727304.0  |   63756742.4  |   64575378.56 |   61044048.64 |

<h4>Таблица #4</h4>

|    4   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1206456320.96 |  443143494.08 |  407327719.04 |  407013029.44 |
| VECTOR | 3161458192.96 |  653433014.08 |  618613750.72 |  217610872.64 |
| AVX    |  438641075.52 |   63356642.56 |   63660352.32 |   60953052.16 |

<h4>Таблица #5</h4>

|    5   |       -O0     |       -O1     |       -O2     |       -O3     |
|:------:|:-------------:|:-------------:|:-------------:|:-------------:|
| SIMPLE | 1206640666.56 |  442867832.96 |  406931645.76 |  407244093.44 |
| VECTOR | 3103675312.96 |  654002534.08 |  614539704.64 |  219158337.92 |
| AVX    |  440524551.36 |   63067849.6  |   62766071.68 |   62159874.24 |

<h4>Финальная таблица</h4>

Данные в таблице имеют размерность такт * $10^6$

| FINAL  |        -O0        |         -O1       |         -O2       |         -O3       |
|:------:|:-----------------:|:-----------------:|:-----------------:|:-----------------:|
| SIMPLE |$1232.13 \pm 32.28$| $444.46 \pm 2.04$ | $407.99 \pm 1.19$ | $411.20 \pm 6.06$ |
| VECTOR |$3152.78 \pm 66.24$| $652.77 \pm 10.10$| $622.43 \pm 22.19$| $219.88 \pm 5.64$ |
| AVX    | $444.74 \pm 9.20$ | $ 62.75 \pm 1$    | $ 62.84 \pm 1.23$ | $61.27  \pm 0.79$ |



